import type { Participant, Match, Ring } from '../types';
import { generateId } from './uuid';

export const generateMatches = (
    seededParticipants: (Participant | 'BYE')[],
    _categoryKey: string,
    ringId: string
): Match[] => {
    const matches: Match[] = [];
    let currentRoundParticipants = seededParticipants;
    let roundNumber = 1;

    // Calculate total rounds
    const totalRounds = Math.log2(seededParticipants.length);

    // We'll store matches in layers.
    const rounds: Match[][] = [];

    while (currentRoundParticipants.length > 1) {
        const nextRoundParticipants: (Participant | 'BYE' | null)[] = [];
        const currentRoundMatches: Match[] = [];

        const roundName = getRoundName(roundNumber, totalRounds);

        for (let i = 0; i < currentRoundParticipants.length; i += 2) {
            const red = currentRoundParticipants[i];
            const blue = currentRoundParticipants[i + 1];

            const matchId = generateId();

            // Determine if we can auto-advance (if one is BYE)
            let winner: Participant | 'BYE' | undefined = undefined;
            if (red === 'BYE' && blue !== 'BYE' && blue !== null) {
                winner = blue;
            } else if (blue === 'BYE' && red !== 'BYE' && red !== null) {
                winner = red;
            } else if (red === 'BYE' && blue === 'BYE') {
                winner = 'BYE';
            }

            const match: Match = {
                id: matchId,
                bout_number: '', // Assigned later
                red: red,
                blue: blue,
                round: roundName,
                ring: ringId,
                winner: winner
            };

            currentRoundMatches.push(match);
            matches.push(match);

            nextRoundParticipants.push(winner || null);
        }

        rounds.push(currentRoundMatches);
        currentRoundParticipants = nextRoundParticipants as any;
        roundNumber++;
    }

    // Link matches (nextMatchId)
    for (let r = 0; r < rounds.length - 1; r++) {
        const currentRound = rounds[r];
        const nextRound = rounds[r + 1];

        for (let i = 0; i < currentRound.length; i++) {
            const currentMatch = currentRound[i];
            const nextMatchIndex = Math.floor(i / 2);
            const nextMatch = nextRound[nextMatchIndex];

            currentMatch.nextMatchId = nextMatch.id;

            if (i % 2 === 0) {
                nextMatch.leftChildId = currentMatch.id;
            } else {
                nextMatch.rightChildId = currentMatch.id;
            }
        }
    }

    return matches;
};

const getRoundName = (roundNum: number, totalRounds: number): string => {
    const diff = totalRounds - roundNum;
    if (diff === 0) return 'Final';
    if (diff === 1) return 'Semi Final';
    if (diff === 2) return 'Quarter Final';
    return `Round ${roundNum}`;
};

export const assignBoutNumbers = (
    rings: Ring[],
    categoryMatchesMap: Map<string, Match[]>
): void => {



    // 1. Clear all existing bout numbers
    categoryMatchesMap.forEach(matches => {
        matches.forEach(m => {
            // Only clear non-locked bouts? 
            // For now, clear all generated bout numbers.
            // But if we have manually added suffix bouts (from Add Player), 
            // we must be careful.
            // The Add Player logic sets "A04A".
            // assignBoutNumbers sets "A04".
            // If we clear "A04A", we lose the player's bout ID.

            // WAIT. New Player bounds are "A04A".
            // If we re-run assignBoutNumbers, "A04" might become "A05".
            // Then "A04A" is orphaned or weird.
            // The user said "ensure it will update".

            // If "A04" changes to "A05", then "A04A" should probably become "A05A".
            // This implies we need to RE-CALCULATE suffixes too!
            // Or we just preserve suffixes?

            // Complex.
            // Let's assume for now we only clear "standard" bout numbers.
            // Or we clear everything and re-generate.
            // But "A05A" is not generated by this function. It's properly static once added?
            // "addLateParticipant" adds a match to the array.
            // That match is in `categoryMatchesMap`.
            // If we clear its bout number, it becomes blank.
            // `assignBoutNumbers` skips BYEs. 
            // But Qualifier matches are not BYEs. They are P vs P.
            // So `assignBoutNumbers` WILL try to assign a number to them!
            // It will assign "A05" to the qualifier match.
            // But we want "A05A".

            // ISSUE: `assignBoutNumbers` knows nothing about qualifiers.
            // It assigns sequential numbers to all non-bye matches in round-order.

            // If we have a qualifier, it is in a round "Qualifier" or similar?
            // `addPlayerLogic` sets round="Qualifier".
            // `assignBoutNumbers` groups by round.
            // It sees "Qualifier" round.
            // It assigns "A01", "A02"... to qualifiers.
            // But we want "A04A".

            // Fix: `assignBoutNumbers` should SKIP 'Qualifier' rounds?
            // And preserve their bout numbers?

            // Or `assignBoutNumbers` should be smart.

            if (m.round !== 'Qualifier') {
                m.bout_number = '';
            }
        });
    });

    rings.forEach(ring => {
        let boutCounter = 1;

        // Process Priority Groups in order (1, 2...)
        const priorities = Object.keys(ring.priorityGroups).map(Number).sort((a, b) => a - b);

        priorities.forEach(priority => {
            const categories = ring.priorityGroups[priority];

            // Initialize indices for each category in this group
            const categoryIndices: Record<string, number> = {};
            const categoryMatches: Record<string, Match[]> = {};

            categories.forEach(catKey => {
                categoryIndices[catKey] = 0;
                categoryMatches[catKey] = categoryMatchesMap.get(catKey) || [];
            });

            let anyMatchesLeft = true;

            // Loop until all matches in this priority group are assigned
            while (anyMatchesLeft) {
                anyMatchesLeft = false;

                categories.forEach(catKey => {
                    const matches = categoryMatches[catKey];
                    let index = categoryIndices[catKey];

                    if (index >= matches.length) return;

                    // We found at least one unassigned match in this category
                    // We will process the ENTIRE current round for this category
                    const currentRoundName = matches[index].round;

                    while (index < matches.length && matches[index].round === currentRoundName) {
                        const match = matches[index];

                        // Assign the match to this ring
                        match.ring = ring.id;

                        const isRedBye = match.red === 'BYE';
                        const isBlueBye = match.blue === 'BYE';

                        // Skip Qualifier matches for standard numbering (but we assigned ring above)
                        if (match.round === 'Qualifier') {
                            index++;
                            continue;
                        }

                        // If not a BYE, assign bout number
                        if (!isRedBye && !isBlueBye) {
                            const ringLetter = ring.name.replace('RING ', '').trim();
                            match.bout_number = `${ringLetter}${boutCounter.toString().padStart(2, '0')}`;
                            boutCounter++;
                        }

                        index++;
                    }

                    // Update the index for this category
                    categoryIndices[catKey] = index;

                    // If there are still matches left in this category (next round), flag to continue
                    if (index < matches.length) {
                        anyMatchesLeft = true;
                    }
                });
            }
        });
    });
};
